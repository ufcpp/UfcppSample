using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace RgiSequenceFinder.TableGenerator
{
    class SourceGenerator
    {
        public static void Write(StreamWriter writer, GroupedEmojis emojis)
        {
            WriteHeader(writer);
            WriteKeycaps(writer, emojis.Keycaps);
            WriteRegionFlags(writer, emojis.RegionFlags);
            WriteTagFlags(writer, emojis.TagFlags);
            WriterOthers(writer, emojis.Others);
            WriteFooter(writer);
        }

        private static void WriteHeader(StreamWriter writer)
        {
            writer.Write(@"// <auto-generated>
// RgiSequenceFinder.TableGenerator
// </auto-generated>

namespace RgiSequenceFinder
{
    partial class RgiTable
    {
");
        }

        private static void WriteFooter(StreamWriter writer)
        {
            writer.Write(@"    }
}
");
        }

        private static void WriteKeycaps(StreamWriter writer, List<(Keycap key, int index)> keycaps)
        {
            writer.Write(@"        private static int FindKeycap(Keycap key) => key.Value switch
        {
");

            foreach (var (key, index) in keycaps)
            {
                writer.Write("            (byte)'");
                writer.Write((char)key.Value);
                writer.Write("' => ");
                writer.Write(index);
                writer.Write(@",
");
            }

            writer.Write(@"            _ => -1,
        };

");
        }

        private static void WriteRegionFlags(StreamWriter writer, List<(RegionalIndicator code, int index)> regionFlags)
        {
            writer.Write(@"        private static int FindRegion(RegionalIndicator region) => region.First switch
        {
");

            foreach (var g in regionFlags.GroupBy(x => x.code.First))
            {
                writer.Write("            (byte)'");
                writer.Write((char)g.Key);
                writer.Write(@"' => region.Second switch
            {
");

                foreach (var (ri, index) in g)
                {
                    writer.Write("                (byte)'");
                    writer.Write((char)ri.Second);
                    writer.Write("' => ");
                    writer.Write(index);
                    writer.Write(@",
");
                }

                writer.Write(@"                _ => -1,
            },
");
            }

            writer.Write(@"            _ => -1,
        };

");
        }

        private static void WriteTagFlags(StreamWriter writer, List<(TagSequence tag, int index)> tagFlags)
        {
            writer.Write(@"        private static int FindTag(TagSequence tags) => tags.LongValue switch
        {
");
            foreach (var (tags, index) in tagFlags)
            {
                writer.Write("            0x");
                writer.Write(tags.LongValue.ToString("X"));
                writer.Write("UL => ");
                writer.Write(index);
                writer.Write(@",
");
            }

            writer.Write(@"            _ => -1,
        };

");
        }

        private static void WriterOthers(StreamWriter writer, List<(string emoji, int index)> others)
        {
            // other 分、いったん Dictionary 実装する。
            // switch のネストになるようにコード生成したい。
            // \uD83D から始まる文字(1F000 台の文字の high surrogate)ばっかりなのでものすごいデータ量減るはずなのと、
            // 今の Dictionary 実装だと Substring (新規 string インスタンスのアロケーション)が発生するので避けたい。
            // (今のこの Dictionary 実装だと 80 KB くらいバイナリサイズが膨らむ。)

            writer.Write(@"        private static System.Collections.Generic.Dictionary<string, int> _otherTable = new()
        {
");

            foreach (var (s, index) in others)
            {
                writer.Write("            { \"");

                foreach (var c in s)
                {
                    writer.Write("\\u");
                    writer.Write(((int)c).ToString("X4"));
                }

                writer.Write("\", ");
                writer.Write(index);
                writer.Write(@" },
");
            }

            writer.Write(@"        };

        private static int FindOther(string s) => _otherTable.TryGetValue(s, out var v) ? v : -1;
");
        }
    }
}
