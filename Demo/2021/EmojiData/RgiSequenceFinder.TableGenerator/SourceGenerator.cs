using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace RgiSequenceFinder.TableGenerator
{
    class SourceGenerator
    {
        public static void Write(StreamWriter writer, GroupedEmojis emojis)
        {
            WriteHeader(writer);
            WriteKeycaps(writer, emojis.Keycaps);
            WriteRegionFlags(writer, emojis.RegionFlags);
            WriteTagFlags(writer, emojis.TagFlags);
            WriterOthers(writer, emojis.Others);
            WriteFooter(writer);
        }

        private static void WriteHeader(StreamWriter writer)
        {
            writer.Write(@"// <auto-generated>
// RgiSequenceFinder.TableGenerator
// </auto-generated>

namespace RgiSequenceFinder
{
    partial class RgiTable
    {
");
        }

        private static void WriteFooter(StreamWriter writer)
        {
            writer.Write(@"    }
}
");
        }

        private static void WriteKeycaps(StreamWriter writer, List<(Keycap key, int index)> keycaps)
        {
            writer.Write(@"        private static int FindKeycap(Keycap key) => key.Value switch
        {
");

            foreach (var (key, index) in keycaps)
            {
                writer.Write("            (byte)'");
                writer.Write((char)key.Value);
                writer.Write("' => ");
                writer.Write(index);
                writer.Write(@",
");
            }

            writer.Write(@"            _ => -1,
        };

");
        }

        private static void WriteRegionFlags(StreamWriter writer, List<(RegionalIndicator code, int index)> regionFlags)
        {
            writer.Write(@"        private static int FindRegion(RegionalIndicator region) => region.First switch
        {
");

            foreach (var g in regionFlags.GroupBy(x => x.code.First))
            {
                writer.Write("            (byte)'");
                writer.Write((char)g.Key);
                writer.Write(@"' => region.Second switch
            {
");

                foreach (var (ri, index) in g)
                {
                    writer.Write("                (byte)'");
                    writer.Write((char)ri.Second);
                    writer.Write("' => ");
                    writer.Write(index);
                    writer.Write(@",
");
                }

                writer.Write(@"                _ => -1,
            },
");
            }

            writer.Write(@"            _ => -1,
        };

");
        }

        private static void WriteTagFlags(StreamWriter writer, List<(TagSequence tag, int index)> tagFlags)
        {
            writer.Write(@"        private static int FindTag(TagSequence tags) => tags.LongValue switch
        {
");
            foreach (var (tags, index) in tagFlags)
            {
                writer.Write("            0x");
                writer.Write(tags.LongValue.ToString("X"));
                writer.Write("UL => ");
                writer.Write(index);
                writer.Write(@",
");
            }

            writer.Write(@"            _ => -1,
        };

");
        }

        private static void WriterOthers(StreamWriter writer, List<(string emoji, int index)> others)
        {
            // other 分、いったん Dictionary 実装する。
            // switch のネストになるようにコード生成したい。
            // \uD83D から始まる文字(1F000 台の文字の high surrogate)ばっかりなのでものすごいデータ量減るはずなのと、
            // 今の Dictionary 実装だと Substring (新規 string インスタンスのアロケーション)が発生するので避けたい。
            // (今のこの Dictionary 実装だと 80 KB くらいバイナリサイズが膨らむ。)

            writer.Write(@"        private static System.Collections.Generic.Dictionary<string, int> _otherTable = new()
        {
");

            foreach (var (s, index) in others)
            {
                writer.Write("            { \"");

                foreach (var c in s)
                {
                    writer.Write("\\u");
                    writer.Write(((int)c).ToString("X4"));
                }

                writer.Write("\", ");
                writer.Write(index);
                writer.Write(@" },
");
            }

            writer.Write(@"        };

        private static int FindOther(string s) => _otherTable.TryGetValue(s, out var v) ? v : -1;
");
        }

#if false
// こういう実装も試してみたという形跡。
//
// ReadOnlySpan<char> 引数を付けつけできるように switch 化したもの。
// そんなに (a, b, c, ...) switch { ... } みたいなやつ、「1文字目が同じなら1つの if になる」みたいな最適化は掛かるけど、
// 代わりに goto が大量にあるコードになって、バイナリサイズは Dictionary<string, int> を持つ実装よりもでかくなった。
// 線形探索になりそうだし Dictionary 実装よりも遅そう。
//
// 素直に、TryGetValue(ReadOnlySpan<char>) ができる StringDictionary を書いた方がよさそう。

        private static void WriteOthers(StreamWriter writer, List<(string emoji, int index)> others)
        {
            writer.Write(@"        private static int FindOther(System.ReadOnlySpan<char> emoji) => emoji.Length switch
        {
");

            foreach (var g in others.GroupBy(x => x.emoji.Length).OrderBy(g => g.Key))
            {
                var length = g.Key;

                writer.Write("            ");
                writer.Write(length);
                writer.Write(" => ");

                for (int i = 0; i < length; i++)
                {
                    if (i == 0) writer.Write('(');
                    else writer.Write(", ");
                    writer.Write("emoji[");
                    writer.Write(i);
                    writer.Write("]");
                }

                writer.Write(@") switch
            {
");

                foreach (var (emoji, index) in g)
                {
                    writer.Write("                ");

                    for (int i = 0; i < length; i++)
                    {
                        if (i == 0) writer.Write('(');
                        else writer.Write(", ");
                        writer.Write("'\\u");
                        writer.Write(((int)emoji[i]).ToString("X4"));
                        writer.Write("'");
                    }

                    writer.Write(") => ");
                    writer.Write(index);
                    writer.Write(@",
");
                }

                writer.Write(@"                _ => -1,
            },
");
            }

            writer.Write(@"            _ => -1,
        };

");
        }
#endif
    }
}
